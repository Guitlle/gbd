import numpy as np
import pymc as mc

from bayesian_models import probabilistic_utils
from bayesian_models.probabilistic_utils import NEARLY_ZERO
from model_utils import *
        
def fit(dm, method='map', data_type='prevalence data'):
    """ Generate an estimate of the beta binomial model parameters
    using maximum a posteriori liklihood (MAP) or Markov-chain Monte
    Carlo (MCMC)

    Parameters
    ----------
    dm : dismod3.DiseaseModel
      the object containing all the data, priors, and additional
      information (like input and output age-mesh)

    data_type : str, optional
      Only data in dm.data with d['data_type'] == data_type will be
      included in the beta-binomial liklihood function

    method : string, optional
      the parameter estimation method, either 'map' or 'mcmc'

    Example
    -------
    >>> import dismod3
    >>> import dismod3.beta_binomial_model as model
    >>> dm = dismod3.get_disease_model(1)
    >>> model.fit(dm, method='map')
    >>> model.fit(dm, method='mcmc')
    """
    if not hasattr(dm, 'vars'):
        initialize(dm, data_type)

    if method == 'map':
        if not hasattr(dm, 'map'):
            dm.map = mc.MAP(dm.vars)
        dm.map.fit(method='fmin_powell', iterlim=500, tol=.001, verbose=1)
        dm.set_map(data_type, dm.vars['rate_stoch'].value)
    elif method == 'mcmc':
        if not hasattr(dm, 'mcmc'):
            dm.mcmc = mc.MCMC(dm.vars)
        dm.mcmc.use_step_method(mc.AdaptiveMetropolis, dm.vars['logit_p_stochs'])
        dm.mcmc.sample(iter=4000, burn=1000, thin=3, verbose=1)
        store_mcmc_fit(dm, dm.vars['rate_stoch'], data_type)


def initialize(dm, data_type='prevalence data'):
    """ Initialize the stochastic and deterministic random variables
    for the beta binomial model of a single age-specific rate function

    Parameters
    ----------
    dm : dismod3.DiseaseModel
      the object containing all the data, priors, and additional
      information (like input and output age-mesh)

    data_type : str, optional
      Only data in dm.data with d['data_type'] == data_type will be
      included in the beta-binomial liklihood function
        TODO: extend this filter mechanism to work by region, sex,
        time...  possibly leverage Django filter object, if it will run
        on windows
    
    Results
    -------
    Sets dm's param_age_mesh and estimate_age_mesh, if they are not
    already set.

    Sets the units of dm

    Finds initial values for rate_stoch, using a Gaussian Process
    approximation

    Creates the PyMC variables for the beta binomial model, and stores
    them in dm.vars
    """
    if dm.get_param_age_mesh() == []:
        dm.set_param_age_mesh([0.0, 10.0, 20.0, 30.0, 40.0,
                               50.0, 60.0, 70.0, 80.0, 90.0, 100.0])
    if dm.get_estimate_age_mesh() == []:
        dm.set_estimate_age_mesh(range(MAX_AGE))

    # use a random subset of the data if there is a lot of it,
    # to speed things up
    data = dm.filter_data(data_type=data_type)
    if len(data) > 25:
        import random
        data = random.sample(data,25)
    dm.set_units(data_type, '(per person-year)')
    dm.fit_initial_estimate(data_type, data)

    dm.vars = setup(dm, dm.filter_data(data_type=data_type), data_type)

def store_mcmc_fit(dm, rate_stoch, data_type):
    """ Store the parameter estimates generated by an MCMC fit of the
    beta-binomial model in the disease_model object
    
    Parameters
    ----------
    dm : dismod3.DiseaseModel
      the object containing all the data, priors, and additional
      information (like input and output age-mesh)

    rate_stoch : PyMC stochastic or deterministic variable

    data_type : str

    Results
    -------
    Save a sketch of the distribution of dm.mcmc.rate_stoch as data of
    the specified data_type

    Notes
    -----
    This method will be used by other models that have beta binomial
    parts as building blocks, so don't simplify the parameters, at
    least not without thinking about where else the function might
    need to be used
    """
    rate = rate_stoch.trace()
    trace_len = len(rate)
    age_len = len(dm.get_estimate_age_mesh())
    
    sr = []
    for ii in xrange(age_len):
        sr.append(sorted(rate[:,ii]))
    dm.set_mcmc('lower_ui', data_type, [sr[ii][int(.025*trace_len)] for ii in xrange(age_len)])
    dm.set_mcmc('median', data_type, [sr[ii][int(.5*trace_len)] for ii in xrange(age_len)])
    dm.set_mcmc('upper_ui', data_type, [sr[ii][int(.975*trace_len)] for ii in xrange(age_len)])
    dm.set_mcmc('mean', data_type, np.mean(rate, 0))

def setup(dm, data_list, est_name, rate_stoch=None):
    """ Generate the PyMC variables for a beta binomial model of
    a single rate function

    Parameters
    ----------
    dm : dismod3.DiseaseModel
      the object containing all the data, priors, and additional
      information (like input and output age-mesh)

    data_list : list of data dicts
      the observed data to use in the beta-binomial liklihood function
      
    est_name : str
      the name used to store the priors for, initial values for, and
      estimations from, this model

    rate_stoch : pymc.Stochastic, optional
      a PyMC stochastic (or deterministic) object, with
      len(rate_stoch.value) == len(dm.get_estimation_age_mesh()).
      This is used to link beta-binomial stochs into a larger model,
      for example.
      
    Results
    -------
    vars : dict
      Return a dictionary of all the relevant PyMC objects for the
      beta binomial model.  vars['rate_stoch'] is of particular
      relevance; this is what is used to link the beta-binomial model
      into more complicated models, like the generic disease model.

    Details
    -------
    The beta binomial model parameters are the following:
      * the mean age-specific rate function
      * confidence in this mean
      * the p_i value for each data observation that has a standard
        error (data observations that do not have standard errors
        recorded are fit as observations of the beta r.v., while
        observations with standard errors recorded have a latent
        variable for the beta, and an observed binomial r.v.
    """
    vars = {}
    est_mesh = dm.get_estimate_age_mesh()
    if np.any(np.diff(est_mesh) != 1):
        raise ValueError, 'ERROR: Gaps in estimation age mesh must all equal 1'

    # set up age-specific rate function, if it does not yet exist
    if not rate_stoch:
        param_mesh = dm.get_param_age_mesh()
        initial_value = dm.get_initial_value(est_name)

        # find the logit of the initial values, which is a little bit
        # of work because initial values are sampled from the est_mesh,
        # but the logit_initial_values are needed on the param_mesh
        logit_initial_value = mc.invlogit(
            probabilistic_utils.interpolate(est_mesh, initial_value, param_mesh))
        
        logit_rate = mc.Normal('logit(%s)' % est_name,
                               mu=np.zeros(len(param_mesh)),
                               tau=1.e-2,
                               value=logit_initial_value,
                               verbose=0)
        vars['logit_rate'] = logit_rate

        @mc.deterministic(name=est_name)
        def rate_stoch(logit_rate=logit_rate):
            return probabilistic_utils.interpolate(param_mesh,
                                                   mc.invlogit(logit_rate), est_mesh)

    vars['rate_stoch'] = rate_stoch

    confidence = mc.Normal('conf_%s' % est_name, mu=1000.0, tau=1./(300.)**2)

    MIN_CONFIDENCE = 1
    MAX_CONFIDENCE = 100000
    
    @mc.deterministic(name='alpha_%s' % est_name)
    def alpha(rate=rate_stoch, confidence=confidence):
        return rate * probabilistic_utils.trim(confidence,
                                               MIN_CONFIDENCE, MAX_CONFIDENCE)

    @mc.deterministic(name='beta_%s' % est_name)
    def beta(rate=rate_stoch, confidence=confidence):
        return (1. - rate) * probabilistic_utils.trim(confidence,
                                                      MIN_CONFIDENCE, MAX_CONFIDENCE)

    vars['conf'] = confidence
    vars['alpha'] = alpha
    vars['beta'] = beta

    # set up priors and observed data
    prior_str = dm.get_priors(est_name)
    vars['priors'] = generate_prior_potentials(prior_str, est_mesh, rate_stoch, confidence)

    vars['logit_p_stochs'] = []
    vars['p_stochs'] = []
    vars['beta_potentials'] = []
    vars['observed_rates'] = []
    for d in data_list:
        # set up observed stochs for all relevant data
        id = d['id']
        
        if d['value'] == MISSING:
            print 'WARNING: data %d missing value' % id
            continue

        # ensure all rate data is valid
        d_val = dm.value_per_1(d)
        d_se = dm.se_per_1(d)
        
        if d_val < 0 or d_val > 1:
            print 'WARNING: data %d not in range [0,1]' % id
            continue

        if d['age_start'] < est_mesh[0] or d['age_end'] > est_mesh[-1]:
            raise ValueError, 'Data %d is outside of estimation range---([%d, %d] is not inside [%d, %d])' \
                % (d['id'], d['age_start'], d['age_end'], est_mesh[0], est_mesh[-1])

        age_indices = indices_for_range(est_mesh, d['age_start'], d['age_end'])
        age_weights = d['age_weights']
        # if the data has a standard error, model it as a realization
        # of a beta binomial r.v.
        if d_se > 0:
            logit_p = mc.Normal('logit(p_%d)' % id, 0., 1/(10.)**2,
                                value=mc.logit(d_val + NEARLY_ZERO),
                                verbose=0)
            p = mc.InvLogit('p_%d' % id, logit_p)

            @mc.potential(name='beta_potential_%d' % id)
            def potential_p(p=p,
                            alpha=alpha, beta=beta,
                            age_indices=age_indices,
                            age_weights=age_weights):
                a = probabilistic_utils.rate_for_range(alpha, age_indices, age_weights)
                b = probabilistic_utils.rate_for_range(beta, age_indices, age_weights)
                return mc.beta_like(probabilistic_utils.trim(p, NEARLY_ZERO, 1. - NEARLY_ZERO), a, b)

            denominator = max(100., d_val * (1 - d_val) / d_se**2.)
            numerator = d_val * denominator
            obs = mc.Binomial('data_%d' % id, value=numerator, n=denominator, p=p, observed=True)

            vars['logit_p_stochs'].append(logit_p)
            vars['p_stochs'].append(p)
            vars['beta_potentials'].append(potential_p)
        else:
            # if the data is a point estimate with no uncertainty
            # recorded, model it as a realization of a beta r.v.
            @mc.observed
            @mc.stochastic(name='data_%d' % id)
            def obs(value=d_val,
                    alpha=alpha, beta=beta,
                    age_indices=age_indices,
                    age_weights=age_weights):
                a = probabilistic_utils.rate_for_range(alpha, age_indices, age_weights)
                b = probabilistic_utils.rate_for_range(beta, age_indices, age_weights)
                return mc.beta_like(probabilistic_utils.trim(value, NEARLY_ZERO, 1. - NEARLY_ZERO), a, b)
            
        vars['observed_rates'].append(obs)
        
    return vars
